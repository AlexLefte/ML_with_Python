{"cells":[{"cell_type":"markdown","source":["# MLP Algorithm on Splice Genes Dataset\n"],"metadata":{"id":"h9AsBJ92id2j"}},{"cell_type":"markdown","source":["This project is supposed to predict whether a specific ARN nucleotides sequence is an **exon/intron/NA**.\n","\n","In order to do so, I tried to implement 3 different types of algorithms: **random forest**, **support vector machine** and finally a **neural network**.\n","\n","The objective is to determine which of these is better in this context and what **parameters** are to be modified in order to achieve the best accuracy for our model."],"metadata":{"id":"KLF_tf4tilpU"}},{"cell_type":"markdown","source":["# Imports (libraries and classes)\n"],"metadata":{"id":"PreMtUhIjisI"}},{"cell_type":"code","source":["import numpy as np\n","from sklearn import datasets, neural_network\n","from sklearn.model_selection import train_test_split\n","from sklearn.preprocessing import OrdinalEncoder\n","from sklearn.preprocessing import LabelEncoder\n","from sklearn.metrics import classification_report\n","from sklearn.metrics import confusion_matrix\n","\n","label_encoder = LabelEncoder()\n","ordinal_encoder = OrdinalEncoder()"],"metadata":{"id":"ygYDarthjmPY"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# Dataset\n"],"metadata":{"id":"josneRjbjvIW"}},{"cell_type":"code","source":["# Funtion which returnes 'True' if the two lists have any elements in common\n","# It returnes 'False' if there are NO elements in common\n","def common_elements(s1, s2): \n","    if s1 & s2:\n","        return True\n","    return False"],"metadata":{"id":"KNPm1EKSllE7"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["data = np.genfromtxt('splice.data',dtype=None, encoding=None,delimiter=',')  # Importing our data \n","data=data[:,[0,2]]      # Reassigning data with only the first and third column\n","a = {'D','N','S','R'}   # Creating a set of ambiguous characters\n","index = []              # Creating a list to which we will append the unwanted rows indexes\n","\n","for i in range(data.shape[0]):\n","    temp = set(data[i][1].strip());             # Assigning the DNA sequence as a set\n","    if common_elements(temp, a) != False:       # Check whether there are any common elements between these sets                     \n","        index.append(i)                         # If so, append the index of the row to be deleted\n","\n","data = np.delete(data, index, 0)                # Delete the rows we don't need"],"metadata":{"id":"TONvMshWlRQz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# Creating our train/test sets"],"metadata":{"id":"5mX0AxeqyPxU"}},{"cell_type":"code","source":["# Creating our features/labels arrays\n","X = np.array(data[:,1:])              # Features array\n","Y = np.array(data[:,:1])              # Labels array\n","\n","X = ordinal_encoder.fit_transform(X)          #Encoding our attribtes (A -> 0, C -> 2, G -> 3, T -> 4)\n","Y = label_encoder.fit_transform(Y.ravel())    #Encoding our labels (EI -> 0, IE -> 1, N -> 2)\n","\n","X_train, X_test, Y_train, Y_test = train_test_split(X, Y, train_size=0.75, test_size=0.25)  # We are going to use a 75 / 25 split (70 / 30 is also ok)"],"metadata":{"id":"Cr7N5DXiyTzw"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# Creating and also testing our classifier for different values of the cost"],"metadata":{"id":"SvYSh0OFzCb2"}},{"cell_type":"code","source":["nr_neuroni = [[10,50,200], [50,10,200], [200,50,10], [20,100,50], [200,100,200], [70,20,150], [150,100,200]]\n","activation = ['logistic', 'relu', 'tanh']\n","\n","for j in activation:\n","        for i in nr_neuroni:\n","                clf = neural_network.MLPClassifier(activation=j,hidden_layer_sizes=(i[0],i[1],i[2]),max_iter=5000).fit(X_train,Y_train)\n","                pred = clf.predict(X_test)\n","                count = 0\n","                for m in range(len(pred)):\n","                    if(pred[m] == Y_test[m]):\n","                        count += 1\n","\n","                print(\"Acuratetea pentru un strat de neuroni cu dimensiunile: \" + str(i[0]) +\", \" + str(i[1]) +\" si \" + str(i[2]) + \n","                      \" si functia de activare '\" + j + \"' este: \" + str(count/len(pred)))\n","                    "],"metadata":{"id":"k3HgUzvlzE1j","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1650190637913,"user_tz":-180,"elapsed":69291,"user":{"displayName":"Alex Lefterache","userId":"15058845770182448453"}},"outputId":"2a5bc79c-18fc-4adb-808b-1844f477f3ed"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["Acuratetea pentru un strat de neuroni cu dimensiunile: 10, 50 si 200 si functia de activare 'logistic' este: 0.7858942065491183\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 50, 10 si 200 si functia de activare 'logistic' este: 0.7997481108312342\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 200, 50 si 10 si functia de activare 'logistic' este: 0.8060453400503779\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 20, 100 si 50 si functia de activare 'logistic' este: 0.8022670025188917\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 200, 100 si 200 si functia de activare 'logistic' este: 0.827455919395466\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 70, 20 si 150 si functia de activare 'logistic' este: 0.7846347607052897\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 150, 100 si 200 si functia de activare 'logistic' este: 0.7947103274559194\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 10, 50 si 200 si functia de activare 'relu' este: 0.3136020151133501\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 50, 10 si 200 si functia de activare 'relu' este: 0.6196473551637279\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 200, 50 si 10 si functia de activare 'relu' este: 0.5037783375314862\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 20, 100 si 50 si functia de activare 'relu' este: 0.5037783375314862\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 200, 100 si 200 si functia de activare 'relu' este: 0.33879093198992444\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 70, 20 si 150 si functia de activare 'relu' este: 0.7443324937027708\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 150, 100 si 200 si functia de activare 'relu' este: 0.6020151133501259\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 10, 50 si 200 si functia de activare 'tanh' este: 0.8022670025188917\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 50, 10 si 200 si functia de activare 'tanh' este: 0.739294710327456\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 200, 50 si 10 si functia de activare 'tanh' este: 0.5037783375314862\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 20, 100 si 50 si functia de activare 'tanh' este: 0.7544080604534005\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 200, 100 si 200 si functia de activare 'tanh' este: 0.5037783375314862\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 70, 20 si 150 si functia de activare 'tanh' este: 0.6939546599496221\n","Acuratetea pentru un strat de neuroni cu dimensiunile: 150, 100 si 200 si functia de activare 'tanh' este: 0.7065491183879093\n"]}]},{"cell_type":"markdown","source":["OBS: We can notice that for this specific problem, the activation functions to handle quie well were ***logistic*** and ***tanh***. Each of them had an overall accuracy > 80%"],"metadata":{"id":"Zqz9LsP1Anln"}}],"metadata":{"colab":{"collapsed_sections":[],"name":"Splice_genes_MLP","provenance":[{"file_id":"/v2/external/notebooks/intro.ipynb","timestamp":1650188976442}]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}