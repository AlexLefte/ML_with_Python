{"cells":[{"cell_type":"markdown","source":["# SVC Algorithm on Splice Genes Dataset\n"],"metadata":{"id":"h9AsBJ92id2j"}},{"cell_type":"markdown","source":["This project is supposed to predict whether a specific ARN nucleotides sequence is an **exon/intron/NA**.\n","\n","In order to do so, I tried to implement 3 different types of algorithms: **random forest**, **support vector machine** and finally a **neural network**.\n","\n","The objective is to determine which of these is better in this context and what **parameters** are to be modified in order to achieve the best accuracy for our model."],"metadata":{"id":"KLF_tf4tilpU"}},{"cell_type":"markdown","source":["# Imports (libraries and classes)\n"],"metadata":{"id":"PreMtUhIjisI"}},{"cell_type":"code","source":["import numpy as np\n","from sklearn import svm\n","from sklearn.model_selection import train_test_split\n","from sklearn.preprocessing import OrdinalEncoder\n","from sklearn.preprocessing import LabelEncoder\n","from sklearn.metrics import classification_report\n","from sklearn.metrics import confusion_matrix\n","\n","label_encoder = LabelEncoder()\n","ordinal_encoder = OrdinalEncoder()"],"metadata":{"id":"ygYDarthjmPY"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# Dataset\n"],"metadata":{"id":"josneRjbjvIW"}},{"cell_type":"code","source":["# Funtion which returnes 'True' if the two lists have any elements in common\n","# It returnes 'False' if there are NO elements in common\n","def common_elements(s1, s2): \n","    if s1 & s2:\n","        return True\n","    return False"],"metadata":{"id":"KNPm1EKSllE7"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["data = np.genfromtxt('splice.data',dtype=None, encoding=None,delimiter=',')  # Importing our data \n","data=data[:,[0,2]]      # Reassigning data with only the first and third column\n","a = {'D','N','S','R'}   # Creating a set of ambiguous characters\n","index = []              # Creating a list to which we will append the unwanted rows indexes\n","\n","for i in range(data.shape[0]):\n","    temp = set(data[i][1].strip());             # Assigning the DNA sequence as a set\n","    if common_elements(temp, a) != False:       # Check whether there are any common elements between these sets                     \n","        index.append(i)                         # If so, append the index of the row to be deleted\n","\n","data = np.delete(data, index, 0)                # Delete the rows we don't need"],"metadata":{"id":"TONvMshWlRQz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# Creating our train/test sets"],"metadata":{"id":"5mX0AxeqyPxU"}},{"cell_type":"code","source":["# Creating our features/labels arrays\n","X = np.array(data[:,1:])              # Features array\n","Y = np.array(data[:,:1])              # Labels array\n","\n","X = ordinal_encoder.fit_transform(X)          #Encoding our attribtes (A -> 0, C -> 2, G -> 3, T -> 4)\n","Y = label_encoder.fit_transform(Y.ravel())    #Encoding our labels (EI -> 0, IE -> 1, N -> 2)\n","\n","X_train, X_test, Y_train, Y_test = train_test_split(X, Y, train_size=0.75, test_size=0.25)  # We are going to use a 75 / 25 split (70 / 30 is also ok)"],"metadata":{"id":"Cr7N5DXiyTzw"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["# Creating and also testing our classifier for different values of the cost"],"metadata":{"id":"SvYSh0OFzCb2"}},{"cell_type":"code","source":["cost = [1/32, 1/8, 1/2, 2, 8, 32, 128]  # Creating a list of costs to train our model with\n","error_rates = np.array([])              # We also want to determine the error rates for each class \n","for i in range(len(cost)):\n","    clf = svm.SVC(kernel='linear',C=cost[i]).fit(X_train, Y_train)  # Creating our SVC model\n","    Y_pred=clf.predict(X_test)                                      # Making predictions on our testing set\n","    \n","    #Calculating error rates using the confusion_matrix\n","    cm = confusion_matrix(Y_test, Y_pred)                               # Creating our confusion matrix\n","    cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]             # Normizing the values\n","    error_rates = np.append(error_rates,(-1)*cm.diagonal()+1,axis=0)    # Calculating the error rates\n","\n","    print('For a value of cost equal to: ' + str(cost[i]) + ' we have obtained:\\n')  # Printing our classification report first\n","    print(classification_report(Y_test, Y_pred)+'\\n\\n')\n","\n","print('Here are the obtained error rates:')  # Printing the error rates\n","print('     EI          IE           N')\n","error_rates=np.reshape(error_rates,(len(cost),3)) # Resizing to 7x3 [costs]/[classes]\n","print(error_rates)"],"metadata":{"id":"k3HgUzvlzE1j"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"collapsed_sections":[],"name":"Splice_genes_SVC","provenance":[{"file_id":"/v2/external/notebooks/intro.ipynb","timestamp":1650188976442}]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}